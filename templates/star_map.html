{% extends "base.html" %}
{% block title %}Star Map{% endblock %}

{% block content %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<div id="starMapPanelContainer" style="display: flex; justify-content: center; align-items: center; height: 100vh; width: 100vw; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
    <div id="starMapPanel" style="width: 80%; height: 80%; position: relative; background-color: black;">
        <button id="fullscreenButton" style="position: absolute; top: 10px; right: 10px; padding: 10px; background: rgba(0, 0, 0, 0.7); color: white; border: none; cursor: pointer;">⛶ Full Screen</button>
        <div id="starLabel" style="position: absolute; color: white; background: rgba(0, 0, 0, 0.7); padding: 5px; font-size: 14px; border-radius: 5px; display: none;"></div>
    </div>
</div>

<script id="stars-data" type="application/json">{{ stars | tojson }}</script>

<script>
document.addEventListener("DOMContentLoaded", function () {
    const container = document.getElementById("starMapPanel");
    const label = document.getElementById("starLabel");
    const fullscreenButton = document.getElementById("fullscreenButton");

    fullscreenButton.addEventListener("click", function () {
        if (!document.fullscreenElement) {
            container.requestFullscreen().catch(err => {
                alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            document.exitFullscreen();
        }
    });

    console.log("Initializing THREE.js scene...");

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    container.appendChild(renderer.domElement);

    const radius = 500;
    camera.position.set(0, 0, radius);
    console.log(`Camera positioned at (0, 0, ${radius})`);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableZoom = true;
    controls.enablePan = false;
    controls.enableRotate = true;
    controls.screenSpacePanning = false;
    controls.target.set(0, 0, 0);
    controls.maxDistance = radius * 2;
    controls.minDistance = radius / 10;

    const starGroup = new THREE.Group();
    scene.add(starGroup);
    console.log("Created starGroup and added to scene.");

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Parse stars + celestial objects from Flask data
    const starsData = JSON.parse(document.getElementById('stars-data').textContent);
    console.log(`Loaded starsData with ${starsData.length} stars.`);

    // Geometry for stars and planets as points
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const sizes = [];

    const loader = new THREE.TextureLoader();

    // Track how many sprites added asynchronously
    let spritesAdded = 0;
    let starsWithIconsCount = 0;

    starsData.forEach(star => {
        const raRad = (star.ra / 360) * Math.PI * 2;
        const decRad = (star.dec / 180) * Math.PI;

        const x = radius * Math.cos(decRad) * Math.cos(raRad);
        const y = radius * Math.sin(decRad);
        const z = radius * Math.cos(decRad) * Math.sin(raRad);

        if (star.icon) {
            starsWithIconsCount++;
            loader.load(star.icon, texture => {
                const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(material);
                sprite.position.set(x, y, z);
                sprite.scale.set(20, 20, 1); // adjust as needed
                sprite.userData = { name: star.name };
                sprite.renderOrder = 999; // force render order to front

                starGroup.add(sprite);
                spritesAdded++;
                console.log(`Added sprite #${spritesAdded} for star: ${star.name}`);

                // After last sprite loaded, log total children count
                if (spritesAdded === starsWithIconsCount) {
                    console.log(`All sprites loaded. starGroup has ${starGroup.children.length} children.`);
                }
            },
            undefined,
            error => {
                console.warn(`Failed to load icon for star: ${star.name}`, error);
            });
        } else {
            positions.push(x, y, z);
            // Optional: Adjust star size by magnitude
            const size = Math.max(0.1, 1.5 - (star.mag * 0.1));
            sizes.push(size);
        }
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

    const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 2,
        sizeAttenuation: true
    });

    const starsMesh = new THREE.Points(geometry, material);
    starGroup.add(starsMesh);
    console.log("Added starsMesh Points to starGroup.");

    // Utility: get accurate mouse coords relative to renderer canvas
    function updateMouseCoords(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        console.log(`Mouse coords updated: x=${mouse.x.toFixed(3)}, y=${mouse.y.toFixed(3)} (canvas relative)`);
    }

    function onMouseMove(event) {
        updateMouseCoords(event);

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(starGroup.children, true);

        console.log(`onMouseMove intersects count: ${intersects.length}`);

        if (intersects.length > 0) {
            const intersect = intersects[0];
            let starName = "Unknown Star";

            if (intersect.object.type === "Sprite") {
                starName = intersect.object.userData.name || starName;
            } else if (intersect.object.type === "Points" && intersect.index !== undefined) {
                starName = starsData[intersect.index]?.name || starName;
            }
            console.log(`Hovered over star: ${starName}`);

            label.innerText = starName;
            label.style.left = event.clientX + 10 + "px";
            label.style.top = event.clientY + 10 + "px";
            label.style.display = "block";
        } else {
            label.style.display = "none";
        }
    }

    function onMouseDoubleClick(event) {
        updateMouseCoords(event);

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(starGroup.children, true);
        console.log(`onMouseDoubleClick intersects count: ${intersects.length}`);

        if (intersects.length > 0) {
            const intersect = intersects[0];
            let star;

            if (intersect.object.type === "Sprite") {
                const name = intersect.object.userData.name;
                star = starsData.find(s => s.name === name);
                console.log(`Double clicked sprite star: ${name}`);
            } else if (intersect.object.type === "Points" && intersect.index !== undefined) {
                star = starsData[intersect.index];
                console.log(`Double clicked points star: ${star.name}`);
            }

            if (star) {
                console.log(`Fetching info for star: ${star.name}`);
                fetchStarInfo(star.name);
            } else {
                console.warn("Star not found on double click intersection");
            }
        } else {
            console.log("No intersected star on double click");
        }
    }

    function fetchStarInfo(starName) {
        console.log(`Fetching star info for: ${starName}`);
        fetch(`/star_info/${encodeURIComponent(starName)}`)
            .then(response => {
                console.log(`Fetch response status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                if (data.error) {
                    console.warn("No info found for " + starName);
                    alert("No info found for " + starName);
                    return;
                }
                console.log("Received star info:", data);
                showStarInfo(data);
            })
            .catch(error => console.error("Error fetching star info:", error));
    }

    function showStarInfo(star) {
        console.log("Showing star info modal for:", star.name);

        const existingModal = document.getElementById("starInfoModal");
        if (existingModal) {
            console.log("Removing existing modal");
            existingModal.remove();
        }

        const modal = document.createElement("div");
        modal.id = "starInfoModal";
        modal.style.position = "fixed";
        modal.style.top = "50%";
        modal.style.left = "50%";
        modal.style.transform = "translate(-50%, -50%)";
        modal.style.background = "black";
        modal.style.color = "white";
        modal.style.padding = "15px";
        modal.style.borderRadius = "8px";
        modal.style.zIndex = 1000;
        modal.style.maxWidth = "300px";
        modal.style.boxShadow = "0 0 10px #fff";

        modal.innerHTML = `
            <h2>${star.name}</h2>
            <p><b>RA:</b> ${star.ra}°</p>
            <p><b>DEC:</b> ${star.dec}°</p>
            <p><b>Magnitude:</b> ${star.mag}</p>
            <p>${star.description || ''}</p>
            <button id="trackStarBtn" class="btn btn-success" style="margin-right: 8px;">Track</button>
            <button id="closeStarInfo" class="btn btn-secondary">Close</button>
        `;

        document.body.appendChild(modal);

        document.getElementById("closeStarInfo").addEventListener("click", () => {
            modal.remove();
            console.log("Star info modal closed");
        });

        document.getElementById("trackStarBtn").addEventListener("click", () => {
            fetch("/track_star", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    name: star.name,
                    ra: star.ra,
                    dec: star.dec,
                    mag: star.mag
                })
            })
            .then(response => response.json())
            .then(data => {
                modal.remove();
            })
            .catch(error => {
                console.error(error);
            });
        });
    }

    function onWindowResize() {
        camera.aspect = container.offsetWidth / container.offsetHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.offsetWidth, container.offsetHeight);
        console.log(`Resized renderer to ${container.offsetWidth}x${container.offsetHeight}`);
    }

    window.addEventListener('resize', () => {
        onWindowResize();
    });

    container.addEventListener('mousemove', onMouseMove);
    container.addEventListener('dblclick', onMouseDoubleClick);

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    console.log("Star map initialization complete.");
});
</script>
{% endblock %}
